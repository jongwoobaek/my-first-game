1. html 부터 완성하자.
 ㅇ가. 메인페이지, 게임페이지, 게임 완료 페이지 총 3가지가 있다. 
 ㅇ나. 메인페이지는 제목, 시작버튼, 그림이 있다.
 ㅇ다. div 를 이용해서 h1, button, img 를 묶자.
 ㅇ라. 메인페이지를 숨겨놓고, 게임페이지를 만들어보자.
 ㅇ마. 게임페이지는 제목, 재시작, 그림, 남은시간, 남은 과일 수 가 나타나야 한다.
 ㅇ바. 그림은 div 를 이용하여 4개가 한 묶음이 되도록 해보자.(그랬을때 메인페이지 그림과 같은 크기가 되도록하자)
 ㅇ사. 남은시간, 남은 과일은 h3 정도로 하자.(숫자는 일단 하드코딩)
 ㅇ아. 게임완료 페이지는 게임페이지와 똑같지만 가운데 그림이 통으로 하나만 들어간다.
 ㅇ자. 남은시간과, 남은 과일이 표시되어야 한다.

2. 메인페이지에서 시작을 눌렀을때 게임페이지로 넘어가야 한다.
 가. 버튼을 dom 으로 잡는다.
 나. 클릭 이벤트를 넣자.
 다. 토글을 이용해서 버튼을 눌렀을 때 메인페이지의 시작버튼과, 사진을 가린다.
 라. 게임페이지의 재시작버튼, 그림, 남은시간, 남은 과일이 나타나야한다.
 마. 먼저 두 html을 합쳐보자.
 바. 게임페이지에는 css와 클래스를 이용하여, display 를 none을 기본값으로 해놓자.

3. 게임페이지에 제한시간을 걸고, 제한시간이 지나면 게임 완료 화면이 나오게 하자.
 가. 게임 페이지에 setimeout 이 걸려있는 동안 사진을 클릭 할 수 있다..
 나. 게임 시작버튼을 클릭한다.
 다. 게임페이지로 넘어가는 코드와 완료 페이지로 넘어가는 코드가 동시에 실행된다.
 라. 하지만 완료페이지로 넘어가는 코드에는 setimeout 이 걸려있다.
 마. 따라서 5초가 대기 시간이라면 5초 뒤에 실행된다.
 바. setimeout 을 반환하는 함수를 만들어보자(쓰로틀 참고)
 사. setimeout 안에 완료 페이지를 띄위도록 로직을 짜야 한다.

4. 처음 선택한 사진과 다음에 선택한 사진의 alt 값이 일치하면 그대로 유지되고, 아니면 둘다 hidden 되어야 한다.
 가. 먼저, 첫번째로 클릭한 사진이 어떤 값을 가지는지 어떻게 확인할까?
 나. 사진을 클릭하면 해당 사진의 alt 값이 배열에 push 된다.
 다. 그 다음 사진을 클릭하면 똑같이 alt 값이 배열에 추가된다.
 라. 만약 arr[0] === arr[1] 이면 toggle 이 안된다.
 마. 그리고 배열의 값을 초기화 한다...흠..
 바. 이 방법으론 도저히 안될듯..
 사. $0 를 이용해보자.
 아. 이벤트 버블링과 위임을 살펴보자.
 자. 카운터를 사용해볼까?

 게임중 재시작 눌렀을때 setTimeout 취소시켜야돼...

5. 모든 사진의 hidden 이 사라졌을 때, setTimeout 이 중지되어야 한다.
 가. result 배열의 요소가 4개이면 setimeout을 종료하고 함수를 종료시킨다.
 나. 아니면 밑에 로직을 진행시킨다.

6. 남은 과일 수를 실시간으로 반영해보자.
 가. 남은 과일 수 - (result.length / 2) = 결과!

7. 타이머를 만들어보자.
 가. setInterval을 이용해보자.

8. 같은 사진이 연속클릭 안되게 해보자.
 가. 고유 아이디를 지정해볼까...
 나. 만약 아이디가 같다면 함수가 실행되지 않아야 한다.
 다. 만약 아이디가 다르다면 함수가 실행된다.
 라. 그러면 아이디를 추가해서 비교하는 배열이 필요하겠네...
 마. checkId 배열을 전역에 만들자.
 바. 클릭하면 checkId 에 해당 이미지의 id 를 push한다.
 사. checkId[0]과 checkId[1] 을 비교후 같은지 다른지 판단한다.
 아. 같으면 checkId를 초기화 시킨다.
 자. 일단 아이디를 생성하는 함수를 만든다.
  1) Math.random() 을 이용해도 될 것 같은데...?
  2) let id = Math.random() 으로 만들고.
  3) checkId 에 id 값을 추가한다.
  4) 근데 제일 먼저, 클릭 이벤트 조건에 checkId[0]과 checkId[1]를 비교하는 조건문이 필요햐다.
  5) 조건문이 true면 실행된다.
  6) 문제가 생겼다....
   가) 클릭할때마다 아이디가 새로 생성되기 때문에 같은 사진을 연속 클릭해도 계속 다른 아이디가 추갇된다...
   나) 그러면 gameImg[i] 의 아이디를 넣는다. 그리고 if(!gameImg[i].id]) 이면 함수가 실행된다. 아니면 실행되지 않는다.
 차. 게임시작, 재시작 때마다 아이디를 새로 생성하고, 새로 입력해야햔다.

 사진 뒤집고,
 비활성화 하고
 제한시간 끝나면 다시 활성화 하고

9. 정답을 맞추면 해당되는 사진들이 다시 클릭되지 않도록 하자.
 가. 조건물으로 해결해보자...
 해결!!!!!

10. 이제 한 번에 2개 이상 클릭이 되지 않게 해보자.
 가. clickCounter 를 이용하자.
 
11. 2개 클릭 했을 때 checkArr 요소가 다르면 바로 다시 감추자.
 가. 그럼 로직을 아예 다시 짜야 될 것 같은데...
 나. 그림을 클릭한다.
 다. 두번째 그림을 클릭 한다.
 라. 두 그림이 alt 값이 같으면 hidden 이 toggle 되지 않고,
 마. 다르면 둘 다 바로 toggle 이 되어야 한다....흠...
 바. checkArr 의 두개 요소가 값이 다르면 clearTimeout을 이용하여 함수를 취소시킨다.
 사. 그리고 그냥 하드코딩 갈기자(모든 이미지에 hidden 을 추가해버려!!!)
  1) gameImg[0].className = 'game-img hidden' 요로케!!!!

  -- 오늘 안에 못끝내면 일단 관두고, 타이머부터 만들어 보자!

  -- 0.6초 보다 빨리누르면 버그가 생기는듯

자, 만약에 goal.innerText = 1 이고, gameImg[i].alt === resultArr[i]
 resultArr.push(gameImg[i].alt)
 gameImg[i].classList.remove('hidden')

12. 이제 타이머를 만들어 보자.
 가. setInterval, 반복문을 사용하면 될가?
 나. setInterval 이 1초마다 실행되고 반복문을 통해 초를 1씩 낮추자.
 다. 그럼 기본값을 5로 설정하고 setIntervald은 4부터 1씩 줄어들게 해야겠네..

13. 이미지 위치를 게임 시작할때마다 랜덤하게 지정하려면?
 가. 이미지 배열을 만들어 이미지 주소를 요소로 넣는다.(momentum 의 background.js 참고)
 나. randomImg 변수를 만든다. 
 다. 이미지 요소를 생성하는 변수를 만든다.
 라. 게임 시작하면, 각각의 square 에 이미지를 넣는다. 반복문 사용
 마. square[0].append(imges[0]) 이런식으로 되도록
 바. 그전에 gameImg = document.createElement("img"); 이런식으로 만든다.
  1) gameImg.src, gameImg.alt, gameImg.class 지정한다.
 라. 이를 실행하는 함수를 만든다.
 마. 그리고 게임 시작버튼을 누를 때마다 실행되도록 한다.
 바. 게임 이미지를 빈 배열로 바꾸고 생성한 이미지들을 배열 안에 푸쉬하는 로직을 추가해야할듯
 사. 추가로 사진이 계속 불러와지지 않는다.
  1) 이거 먼저 해결해야햘듯
  


 -- splice 써야할듯 


 <img
            class="game-img hidden"
            src="https://images.unsplash.com/photo-1559181567-c3190ca9959b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTB8fGZydWl0c3xlbnwwfHwwfHw%3D&auto=format&fit=crop&w=600&q=60"
            alt="cherry"
          />
